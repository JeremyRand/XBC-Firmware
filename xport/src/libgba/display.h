#ifndef CDISPLAY_H
#define CDISPLAY_H

#include "gba.h"

class CPalette;
class CDispFont;

// This class provides utility functions for the GBA display memory
// The display RAM is broken into four "Char Base Blocks", each
// containing 8 "Screen Base Blocks".  Each background pane can be set
// to use tiles in Char Base Blocks 0 - 3.  Char Base Blocks 4 and 5
// are for sprite tiles.  In display mode 3 the background spills over
// into block 4, so only 5 is available for sprite tiles.  Summary
// of addresses follows:
//    CBB  SBB    Addr       Usage
//     0   0-7    0x6000000  Tile or background data
//     1   8-15   0x6004000  Tile or background data
//     2   16-23  0x6008000  Tile or background data
//     3   24-31  0x600C000  Tile or background data
//     4   32-39  0x6010000  Sprite Tiles or Mode 3 bitmap spillover data
//     5   40-47  0x6014000  Sprite Tiles

class CDisplay {
protected:
  CDisplay() {}
  ~CDisplay() {}

public:
  // Because GBA_BASE_VRAM is unsigned short *, it will automatically
  // multiply what we add to it by 2.  Therefore instead of adding
  // 0x4000 to advance each CharBaseBlock, we only add 0x2000.  The
  // same goes for the ScreenBaseBlock.
  static unsigned short *CharBaseBlockAddr(int n) {
    return(((n)*0x2000)+GBA_BASE_VRAM);
  }
  static unsigned short *ScreenBaseBlockAddr(int n) {
    return(((n)*0x400)+GBA_BASE_VRAM);
  }

  // CDisplay holds onto a pointer to the current font and palette so
  // that they do not need to be passed into every function These
  // default to NULL, and are typically set by display context Setup
  // and Focus calls.  CDisplay does not handle cleanup.  It is
  // assumed that cleanup is handled externally, and that
  // SetCurrDispFont or SetCurrPalette would be used to remove a
  // CDispFont or CPalette before they are deleted.
  static void SetCurrPalette(CPalette const *palette);
  static CPalette const *GetCurrPalette();

  static void SetCurrDispFont(CDispFont const *font);
  static CDispFont const *GetCurrDispFont();
  
protected:
  static CDispFont const *m_currFont;
  static CPalette const *m_currPalette;
};

// The size in words of a single tile
#define GBA_TILE_WORD_SIZE  32

// This class represents a set of 8x8 pixel tiles to be used for tiled
// background modes and sprites
class CTileSet {
public:
  // Create a tile set from already existing data, such as that
  // generated by gfx2gba.  This memory will not be altered (meaning
  // that SetTile will fail) and will not be freed on destruct.
  CTileSet(unsigned short charBaseBlock, int nTiles, 
	   unsigned short const *data);

  // Create a tile set to be dynamically modified.  This can be
  // dynamically altered (meaning that SetTile will succeed) and the
  // data will be freed on destruct.
  CTileSet(unsigned short charBaseBlock, int nTiles);

  virtual ~CTileSet();

  // Get and set the char base block for this font (0-3)
  int GetCharBaseBlock() const { return(m_charBaseBlock); }
  void SetCharBaseBlock(int block) { 
    if(block >= 0 && block < 4) m_charBaseBlock = block; 
  }

  // For a given tile index, get the offset in words of the start of a
  // given tile.  Each pixel takes 1 byte, so two pixels fit in each
  // word.  Each tile is 8x8 pixels, which is 64 bytes, or 32 words.
  // Location in local buffer is m_data + GetTileOffset(tileIndex), and in
  // GBA Display RAM is GetGBABaseAddr + GetTileOffset(tileIndex).
  static inline unsigned short GetTileOffset(int tileIndex) {
    return(tileIndex*GBA_TILE_WORD_SIZE);
  }
    
  // Get the GBA Display RAM base address of where this tile set will
  // be written
  unsigned short *GetGBABaseAddr() const {
    return(CDisplay::CharBaseBlockAddr(m_charBaseBlock));
  }

  // This copies the tile set into the GBA Display RAM.  This may have
  // to wait for display vsync, so it can potentially take a while...
  void WriteToGBA() const;

protected:
  // Number of the Char Base Block containing the font (0-3)
  unsigned short m_charBaseBlock;
  // Number of tiles in the tile set
  unsigned short m_nTiles;

  // Local copy of tile data
  unsigned short *m_data;	
  // If set, delete m_data on destruct, otherwise leave it alone
  bool m_ownsStorage;		
};

// This class provides support for creating and using a display font
// on the GBA in tiled display mode
class CDispFont : public CTileSet {
public:
  CDispFont(unsigned char charBaseBlock, const CPalette &palette);
  virtual ~CDispFont();

  // Given an Ascii code and a bool for reverse video, return the tile
  // index of that character
  static inline unsigned short AsciiToTileIndex(unsigned char c, 
					       bool reverse=false) {
    if(c>=32 && c<128) {
      return((c-32) + (reverse?128:0));
    }
    else {
      return(0);
    }
  }
  
  // Given an Ascii code and a bool for reverse video, return the word
  // offset of the start of that character
  static inline unsigned short AsciiToTileOffset(unsigned char c, 
						 bool reverse=false) {
    return(GetTileOffset(AsciiToTileIndex(c,reverse)));
  }

  // This generates the data in the tile set.  It is called from the
  // constructor, and can also be called to regenerate after a change
  // to the palette
  void SetupTileData();

protected:
  const CPalette &m_palette;
};

// class CFontUser
// {
// protected:
// 	bool m_areFontsLoaded;
// public:
// 	CFontUser();
// 	~CFontUser();
// 	void LoadFonts();
// 	bool AreFontsLoaded() { return m_areFontsLoaded; }
// };
#endif
