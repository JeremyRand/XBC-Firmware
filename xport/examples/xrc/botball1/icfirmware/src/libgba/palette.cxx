#include "palette.h"
#include <string.h>
#include <stdlib.h>

// Create a palette from already existing data, such as that
// generated by gfx2gba.  This memory will not be altered (meaning
// that SetColor will fail) and will not be freed on destruct.
CPalette::CPalette(Type type, unsigned short const *data, 
		   int textFgIndex, int textBgIndex) :
  m_type(type), m_ownsStorage(false),
  m_textFgIndex(textFgIndex), m_textBgIndex(textBgIndex)
{
  m_data = (unsigned short *)data;
}

// Create a palette to be dynamically modified.  This can be
// dynamically altered (meaning that SetColor will succeed) and will
// be freed on destruct.
CPalette::CPalette(Type type, int textFgIndex, int textBgIndex) :
  m_type(type), m_ownsStorage(true),
  m_textFgIndex(textFgIndex), m_textBgIndex(textBgIndex)
{
  m_data = (unsigned short *)malloc(PAL_SIZE*sizeof(unsigned short));
}
  
CPalette::~CPalette() 
{
  if(m_ownsStorage) delete m_data;
}

// Support copy of palette data from static initializer, such as that
// generated by gfx2gba
void 
CPalette::CopyFromBuffer(unsigned short const *data)
{
  memcpy(m_data, data, sizeof(unsigned short) * PAL_SIZE);
}

// Inverts all colors
void 
CPalette::Invert()
{
	unsigned short *ptr;
	
	for(ptr = m_data; ptr < m_data + PAL_SIZE; ptr++)
	{
		*ptr = ~ (*ptr);
	}
}

// Inverts value (HSV-wise) of all colors
// VERY crude hack; was trying not to use much CPU time.
void 
CPalette::InvertValue()
{
	unsigned short *ptr;
	unsigned short b, g, r;
	unsigned short max, min, brightness;
	unsigned short delta;
	
	for(ptr = m_data; ptr < m_data + PAL_SIZE; ptr++)
	{
		r = (*ptr)&0x1F;
		g = ((*ptr)>>5)&0x1F;
		b = ((*ptr)>>10)&0x1F;
		
		//brightness = max(r, max(g, b));
		max = ((r) > (((g) > (b) ? (g) : (b))) ? (r) : (((g) > (b) ? (g) : (b))));
		min = ((r) < (((g) < (b) ? (g) : (b))) ? (r) : (((g) < (b) ? (g) : (b))));
		brightness = (max + min)>>1;
		delta = ((0x1F - brightness)<<1)-0x1F;
		
		// 0x1F-B would be 100%, 50%, 0%
		// (0x1F-B)<<1 would be 200%, 100%, 0%
		// ((0x1F-B)<<1)-100% would be 100%, 0%, -100%
		
		// 0% becomes 100%
		// 50% becomes 50%
		// 100% becomes 0%
		
		r+=delta;
		g+=delta;
		b+=delta;
		
		// Clip max at 0x1F
		r = ((r) < (0x1F) ? (r) : (0x1F));
		g = ((g) < (0x1F) ? (g) : (0x1F));
		b = ((b) < (0x1F) ? (b) : (0x1F));
		
		// Clip min at 0x0
		r = ((r) > (0) ? (r) : (0));
		g = ((g) > (0) ? (g) : (0));
		b = ((b) > (0) ? (b) : (0));
		
		//r&=0x1F;
		//g&=0x1F;
		//b&=0x1F;
		
		*ptr = (b<<10)|(g<<5)|r;
	}
}

// This copies the palette into the GBA Palette RAM.  This may have to
// wait for display vsync, so it can potentially take a while...
// TODO: Does it really matter about vsync?  If so fix this.  Also
// consider using DMA
void 
CPalette::WriteToGBA() const
{
  memcpy(GetGBABaseAddr(), m_data, sizeof(unsigned short) * PAL_SIZE);
}
