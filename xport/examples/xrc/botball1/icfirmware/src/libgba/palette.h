#ifndef PALETTE_H
#define PALETTE_H

#include "gba.h"

// Number of indices in a palette
#define PAL_SIZE 256

// The CPalette class is used to manage 256 color palettes and
// transfer them to palette RAM.  16 color palettes are not supported.
typedef unsigned short TPalColor;

class CPalette
{
public:
  enum Type {
    BKGND  = 0,
    OBJ    = 1
  };    

public:
  // Create a palette from already existing data, such as that
  // generated by gfx2gba.  This memory will not be altered (meaning
  // that SetColor will fail) and will not be freed on destruct.
  CPalette(Type type, unsigned short const *data, 
	   int fgTextIndex, int bgTextIndex=0);

  // Create a palette to be dynamically modified.  This can be
  // dynamically altered (meaning that SetColor will succeed) and the
  // data will be freed on destruct.
  CPalette(Type type, int fgTextIndex, int bgTextIndex=0);

  ~CPalette();

  // Get and set the type.  BKGND is used for the background, OBJ is
  // used for sprites.
  Type GetType() const { return(m_type); }
  void SetType(Type type) { m_type = type; }

  // Get and set the indicies for the text foreground and background colors.
  int GetTextFgIndex() const { return(m_textFgIndex); } 
  int GetTextBgIndex() const { return(m_textBgIndex); } 

  void SetTextFgIndex(int index) { m_textFgIndex=index; }
  void SetTextBgIndex(int index) { m_textBgIndex=index; }

  // Convert 5-bit r, g, and b values to and from TPalcolor
  static inline TPalColor PackColor(unsigned char r, unsigned char g, 
			     unsigned char b) {
    return((r&0x1f) | ((g&0x1f)<<5) | ((b&0x1f)<<10));
  }
  static inline void UnpackColor(TPalColor color, unsigned char &r, 
				 unsigned char &g, unsigned char &b) {
    r= (unsigned char) (color&0x1f);
    g= (unsigned char) (color>>5)&0x1f;
    b= (unsigned char) (color>>10)&0x1f;
  }

  // Get and set the color at each index in the palette.  The range of
  // values for r, g, and b are 0 to 31.  Set only works if the
  // palette owns the storage, see constructors for details.
  TPalColor GetColor(int index) const {
    if(index<0 || index>=PAL_SIZE) {
      return(0);
    }
    else {
      return(m_data[index]);
    }
  }

  bool SetColor(int index, TPalColor color) {
    if(!m_ownsStorage || index<0 || index>=PAL_SIZE) {
      return(false);
    }
    else {
      m_data[index] = color;
    }
  }

  bool SetColor(int index, 
		unsigned char r, unsigned char g, unsigned char b) {
    return(SetColor(index, PackColor(r,g,b)));
  }

  // Support copy of palette data from static initializer, such as that
  // generated by gfx2gba
  void CopyFromBuffer(unsigned short const *data);

  // Support transfer to GBA Palette RAM based on the type of the palette

  // Get the GBA Palette RAM base address of where this palette will
  // be written.  This depends on Type: 0x5000000 for BKGND, 0x5000200
  // for OBJ
  unsigned short *GetGBABaseAddr() const {
    return(GBA_BASE_PAL_RAM + 0x100 * m_type);
  }

  // This copies the palette into the GBA Palette RAM.  This may have
  // to wait for display vsync, so it can potentially take a while...
  void WriteToGBA() const;

  void Invert();
  void InvertValue();

protected:
  unsigned short m_textFgIndex;
  unsigned short m_textBgIndex;
  Type m_type;

  unsigned short *m_data;	// Local copy of palette data
  bool m_ownsStorage;		// If set, delete m_data on
				// destruct, otherwise leave it alone
};
#endif
