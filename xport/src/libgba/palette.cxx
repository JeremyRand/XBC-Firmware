#include "palette.h"
#include <string.h>
#include <stdlib.h>

// Create a palette from already existing data, such as that
// generated by gfx2gba.  This memory will not be altered (meaning
// that SetColor will fail) and will not be freed on destruct.
CPalette::CPalette(Type type, unsigned short const *data, 
		   int textFgIndex, int textBgIndex) :
  m_type(type), m_ownsStorage(false),
  m_textFgIndex(textFgIndex), m_textBgIndex(textBgIndex)
{
  m_data = (unsigned short *)data;
}

// Create a palette to be dynamically modified.  This can be
// dynamically altered (meaning that SetColor will succeed) and will
// be freed on destruct.
CPalette::CPalette(Type type, int textFgIndex, int textBgIndex) :
  m_type(type), m_ownsStorage(true),
  m_textFgIndex(textFgIndex), m_textBgIndex(textBgIndex)
{
  m_data = (unsigned short *)malloc(PAL_SIZE*sizeof(unsigned short));
}
  
CPalette::~CPalette() 
{
  if(m_ownsStorage) delete m_data;
}

// Support copy of palette data from static initializer, such as that
// generated by gfx2gba
void 
CPalette::CopyFromBuffer(unsigned short const *data)
{
  memcpy(m_data, data, sizeof(unsigned short) * PAL_SIZE);
}

// This copies the palette into the GBA Palette RAM.  This may have to
// wait for display vsync, so it can potentially take a while...
// TODO: Does it really matter about vsync?  If so fix this.  Also
// consider using DMA
void 
CPalette::WriteToGBA() const
{
  memcpy(GetGBABaseAddr(), m_data, sizeof(unsigned short) * PAL_SIZE);
}
