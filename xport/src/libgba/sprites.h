#ifndef SPRITES_H
#define SPRITES_H

#include "gba.h"
#include "iinterrupt.h"

// Number of indices available for sprites
#define MAX_SPRITE_NUM 128

class CPalette;
class CTileSet;
class CSpriteSet;
class CInterruptCont;

// OAM memory layout.  This was the original bitfield version which 
// needs to be changed because of #pragma pack(1) bug
// struct OAMAttrib0
// {
// 	volatile unsigned short yPos : 8;
// 	volatile unsigned short rotScaleFlag : 1;
// 	volatile unsigned short dblOrDisableFlag : 1;
// 	volatile unsigned short mode : 2;
// 	volatile unsigned short mosaicFlag : 1;
// 	volatile unsigned short colorSize : 1;
// 	volatile unsigned short shape : 2;
// } PACKED;

// struct OAMAttrib1
// {
// 	volatile unsigned short xPos : 9;
// 	volatile unsigned short rotScaleParamSel : 5;
// 	volatile unsigned short size : 2;
// } PACKED;

// struct OAMAttrib2
// {
// 	volatile unsigned short tileNum : 10;
// 	volatile unsigned short priority : 2;
// 	volatile unsigned short palette : 4;
// } PACKED;

// struct OAMAttribs
// {
//   volatile OAMAttrib0 a0;
//   volatile OAMAttrib1 a1;
//   volatile OAMAttrib2 a2;
//   volatile short rotScaleParam;
// } PACKED;

// #define g_OAMAttribs ((volatile OAMAttribs *)GBA_BASE_OAM)

struct OAMAttribs
{
  unsigned short a0;
  unsigned short a1;
  unsigned short a2;
  unsigned short rotScaleParam;
};

///////////////////////////////////////////////////////////////////////////
// The CSprite class holds the data for a single sprite.  In order for
// this to be useful it needs to be associated with a CSpriteSet which
// manages the memory shadowing and transfers for a block of sprites.
// This is done by calling spriteSet.Register(sprite).  Only one
// CSpriteSet can be active at a time since it uses the vblank
// interrupt.  The best way to achieve this is to use it as part of a
// display context (see display.h).
class CSprite
{
public:
  // Create a sprites from already existing data, such as that
  // generated by gfx2gba.  This memory will not be altered (meaning
  // that SetColor will fail) and will not be freed on destruct.
  CSprite(CTileSet &tileSet, int tileIndex, bool initShow=true,
	  unsigned short initX=0, unsigned short initY=0) :
    m_tileSet(tileSet), m_tileIndex(tileIndex), 
    m_xPos(initX), m_yPos(initY), m_show(initShow), 
    m_useRot(false), m_xFlip(false), m_yFlip(false), m_rot(0), 
    m_spriteSet(0)
  {}
  virtual ~CSprite();

  // Get and set the tile info
  int GetTileIndex() const { return(m_tileIndex); } 
  CTileSet &GetTileSet() const { return(m_tileSet); } 
  int GetSpriteIndex() const { return(m_spriteIndex); } 

  void SetTileIndex(int index) { m_tileIndex=index; UpdateSpriteSet();}

  virtual void GetPos(unsigned short &x, unsigned short &y) const {
    x = m_xPos;
    y = m_yPos;
  }
  virtual void SetPos(unsigned short x, unsigned short y) {
    m_xPos = x;
    m_yPos = y;
    m_show = true;
    UpdateSpriteSet();
  }

  void Hide() { SetVisible(false); }
  void Show() { SetVisible(true); }

  virtual void SetVisible(bool show) {
    if(m_show!=show) {
      m_show=show; 
      UpdateSpriteSet();
    }
  }
  bool GetVisible() { return(m_show); }

  // You can do EITHER rotation or reflection, but not both, so these
  // override one another
  virtual void SetFlip(bool xFlip, bool yFlip) {
    m_useRot = false;
    m_xFlip = xFlip;
    m_yFlip = yFlip;
    UpdateSpriteSet();
  }
  // Valid rotation values are 0 - 31
  virtual void SetRot(unsigned short rot) {
    m_useRot = true;
    m_rot = rot;
    UpdateSpriteSet();
  }

  // This copies the sprite info into the OAM memory layout.  Pass in
  // a pointer to the shadow memory entry for the given sprite and it
  // will fill in the memory image for the sprite OAM entry
  // appropriately.  Be aware that OAM memory is only word-writable so
  // bytewise writes to OAM memory result in every other byte being
  // lost...
  bool WriteOAMAttribs(OAMAttribs *spriteAttribMem) const;

  // This is called by CSpriteSet when a sprite is added.  A sprite
  // can only be part of one set
  virtual void RegisterSpriteSet(CSpriteSet &set, int spriteIndex) {
    m_spriteSet = &set;
    m_spriteIndex = spriteIndex;
  }

  // This is called by CSprite methods that require changes to the OAM
  // attributes.  This tells the sprite set to modify the shadow memory
  // for this sprite index
  virtual void UpdateSpriteSet();

protected:
  CTileSet &m_tileSet;
  unsigned short m_tileIndex;
  unsigned short m_xPos;
  unsigned short m_yPos;
  bool m_show;
  bool m_useRot;
  bool m_xFlip;
  bool m_yFlip;
  unsigned short m_rot;
  unsigned short m_spriteIndex;
  CSpriteSet *m_spriteSet;
};

////////////////////////////////////////////////////////////////////////////
// Inherit from IIinterrupt, an interrupt callback interface, to enable 
class CSpriteSet :  public IInterrupt 
{
public:
  CSpriteSet(CInterruptCont *pIntCont=NULL);
  virtual ~CSpriteSet();

  // Register the sprite and put in next free entry, returns the index
  // of the entry, or -1 if the maximum number of sprites are already
  // registered
  short RegisterSprite(CSprite &sprite, bool giveOwnership);

  // Setup display control registers to enable sprites and initialize
  // OAM memory assuming that the video mode and tile sets have
  // already been set up, but the sprite-related memory is in an
  // unknown state.
  void SetupDisplay();
  void ReleaseDisplay();

  // Iterate over all registered sprites and call each to setup shadow
  // memory
  void SetupShadowMem();
  void UpdateShadowMem(int spriteNum);
  
  // The following wait for vertical blanking and write to GBA OAM
  // memory.  The first initializes all entries, the second just
  // updates what it needs to based on what has changed.  If the
  // interrupt controller is set, these should do need to be called.
  // SetupShadowMem() and UpdateShadowMem() set the flags necessary
  // for the vblank interrupt to automatically mirror the apropriate
  // section of shadow ram to OAM memory.
  void WriteAllToGBA();
  void WriteUpdatesToGBA();
  void WriteEntriesToGBA(int startIndex, int num);

protected:
  // These assume that we're already in vblank and are save to call
  // from interrupt
  bool _WriteEntriesToGBA(int startIndex, int num);
  bool _WriteUpdatesToGBA();
  
  // from IInterrupt interface
  virtual void Interrupt(unsigned char vector);

protected:
  // Number of active CSprite objects
  int      m_snum;	

  // Flags for dealing with updates and interrupt service
  bool m_lockShadowMem;
  bool m_GBAUpdateNeeded;
  unsigned short m_minChanged;
  unsigned short m_maxChanged;

  CInterruptCont *m_intCont;

  // Array of pointers to CSprite objects
  CSprite *m_sprites[MAX_SPRITE_NUM];
  
  // Array of ownership flags, if true CSpriteSet should free the
  // sprite when deleted, otherwise an external entity must take
  // responsibility for freeing the sprite appropriately.
  bool m_ownsSprites[MAX_SPRITE_NUM];

  // Shadow memory staging area which gets written to OAM memory
  // during VBLANK
  OAMAttribs m_shadowMem[MAX_SPRITE_NUM];


};
#endif
